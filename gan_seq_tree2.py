# -*- coding: utf-8 -*-
__author__ = 'keven'
"""This code is based on https://github.com/LantaoYu/SeqGAN."""

import tensorflow as tf
from tensorflow.python.ops import tensor_array_ops, control_flow_ops
import numpy as np
import random
import networkx as nx
import utils


class Generator(object):
    def __init__(self, num_emb, batch_size, emb_dim, hidden_dim,
                 sequence_length, start_token, input_length=5,
                 learning_rate=0.01, reward_gamma=0.95, graph_file="graph2.txt"):
        self.num_emb = num_emb
        self.batch_size = batch_size
        self.emb_dim = emb_dim
        self.hidden_dim = hidden_dim
        self.sequence_length = sequence_length
        self.input_length = input_length
        self.output_length = sequence_length - input_length
        self.start_token = tf.constant([start_token] * self.batch_size, dtype=tf.int32)
        self.learning_rate = tf.Variable(float(learning_rate), trainable=False)
        self.reward_gamma = reward_gamma
        self.g_params = []
        self.d_params = []
        self.temperature = 1.0
        self.grad_clip = 5.0

        graph = nx.read_edgelist(graph_file, nodetype=int, create_using=nx.DiGraph())
        self.adj = tf.constant(np.asarray(nx.adjacency_matrix(graph).todense()).transpose(), dtype=tf.int32, shape=[num_emb, num_emb])

        self.expected_reward = tf.Variable(tf.zeros([self.sequence_length]))

        with tf.variable_scope('generator'):
            self.g_embeddings = tf.Variable(self.init_matrix([self.num_emb, self.emb_dim]))
            self.g_params.append(self.g_embeddings)
            self.g_recurrent_unit = self.create_recurrent_unit(self.g_params)  # maps h_tm1 to h_t for generator
            self.g_output_unit = self.create_output_unit(self.g_params)  # maps h_t to o_t (output token logits)

        # placeholder definition
        self.x = tf.placeholder(tf.int32, shape=[self.batch_size, self.sequence_length]) # sequence of tokens generated by generator
        self.rewards = tf.placeholder(tf.float32, shape=[self.batch_size, self.output_length]) # get from rollout policy and discriminator

        # processed for batch
        self.processed_x = tf.transpose(tf.nn.embedding_lookup(self.g_embeddings, self.x), perm=[1, 0, 2])  # seq_length x batch_size x emb_dim
        self.x_seq = tf.transpose(self.x, perm=[1, 0])

        # Initial states
        self.h0 = tf.zeros([self.batch_size, self.hidden_dim])
        self.h0 = tf.stack([self.h0, self.h0])

        self.pretrain()
        self.generate()
        self.update()


    def pretrain(self,):
        g_predictions = tensor_array_ops.TensorArray(
            dtype=tf.float32, size=self.sequence_length,
            dynamic_size=False, infer_shape=True)

        ta_emb_x = tensor_array_ops.TensorArray(
            dtype=tf.float32, size=self.sequence_length)
        ta_emb_x = ta_emb_x.unstack(self.processed_x)

        def _pretrain_recurrence(i, x_t, h_tm1, g_predictions):
            h_t = self.g_recurrent_unit(x_t, h_tm1)
            o_t = self.g_output_unit(h_t)
            g_predictions = g_predictions.write(i, tf.nn.softmax(o_t))  # batch x vocab_size
            x_tp1 = ta_emb_x.read(i)
            return i + 1, x_tp1, h_t, g_predictions

        _, _, _, self.g_predictions = control_flow_ops.while_loop(
            cond=lambda i, _1, _2, _3: i < self.sequence_length,
            body=_pretrain_recurrence,
            loop_vars=(tf.constant(0, dtype=tf.int32),
                       tf.nn.embedding_lookup(self.g_embeddings, self.start_token),
                       self.h0, g_predictions))

        self.g_predictions = tf.transpose(self.g_predictions.stack(), perm=[1, 0, 2])  # batch_size x seq_length x vocab_size

        # pretraining loss
        self.pretrain_loss = -tf.reduce_sum(
            tf.one_hot(tf.to_int32(tf.reshape(self.x, [-1])), self.num_emb, 1.0, 0.0) * tf.log(
                tf.clip_by_value(tf.reshape(self.g_predictions, [-1, self.num_emb]), 1e-20, 1.0)
            )
        ) / (self.sequence_length * self.batch_size)

        # training updates
        pretrain_opt = self.g_optimizer(self.learning_rate)

        self.pretrain_grad, _ = tf.clip_by_global_norm(tf.gradients(self.pretrain_loss, self.g_params), self.grad_clip)
        self.pretrain_updates = pretrain_opt.apply_gradients(zip(self.pretrain_grad, self.g_params))


    def generate(self,):
        # supervised pretraining for generator
        ta_emb_x = tensor_array_ops.TensorArray(
            dtype=tf.float32, size=self.sequence_length)
        ta_emb_x = ta_emb_x.unstack(self.processed_x)

        ta_ind_x = tensor_array_ops.TensorArray(
            dtype=tf.int32, size=self.sequence_length)
        ta_ind_x = ta_ind_x.unstack(self.x_seq)


        def _pretrain_recurrence_2(i, x_t, h_tm1, g_predictions, neighbor):
            h_t = self.g_recurrent_unit(x_t, h_tm1)
            o_t = self.g_output_unit(h_t)
            prob = tf.nn.softmax(o_t)  *  tf.cast(neighbor, tf.float32)
            prob = tf.nn.l2_normalize(prob, dim=1)
            g_predictions = g_predictions.write(i, prob)  # batch x vocab_size
            x_tp1 = ta_emb_x.read(i)
            x_ind = ta_ind_x.read(i)
            # temp = tf.gather_nd(self.adj, x_ind)
            temp = tf.nn.embedding_lookup(self.adj, x_ind)
            neighbor = 1 - tf.cast(tf.equal(tf.zeros_like(temp), temp + neighbor), tf.int32)
            return i + 1, x_tp1, h_t, g_predictions, neighbor

        def _g_recurrence_2(i, x_t, h_tm1, gen_o, gen_x, g_predictions, neighbor):
            h_t = self.g_recurrent_unit(x_t, h_tm1)  # hidden_memory_tuple
            o_t = self.g_output_unit(h_t)
            prob = tf.nn.softmax(o_t)  *  tf.cast(neighbor, tf.float32)
            prob = tf.nn.l2_normalize(prob, dim=1)
            g_predictions = g_predictions.write(i + self.input_length, prob)  # batch x vocab_size
            log_prob = tf.log(prob)
            next_token = tf.cast(
                tf.reshape(tf.multinomial(log_prob, 1), [self.batch_size]), tf.int32)
            x_tp1 = tf.nn.embedding_lookup(self.g_embeddings, next_token)  # batch x emb_dim
            gen_o = gen_o.write(i, tf.reduce_sum(tf.multiply(tf.one_hot(next_token, self.num_emb, 1.0, 0.0),
                                                             tf.nn.softmax(o_t)), 1))  # [batch_size] , prob
            gen_x = gen_x.write(i, next_token)  # indices, batch_size

            # temp = tf.gather_nd(self.adj, [next_token])
            temp = tf.nn.embedding_lookup(self.adj, next_token)
            neighbor = 1 - tf.cast(tf.equal(tf.zeros_like(temp), temp + neighbor), tf.int32)
            return i + 1, x_tp1, h_t, gen_o, gen_x, g_predictions, neighbor

        g_predictions_2 = tensor_array_ops.TensorArray(
            dtype=tf.float32, size=self.sequence_length,
            dynamic_size=False, infer_shape=True)

        gen_o_f2 = tensor_array_ops.TensorArray(dtype=tf.float32, size=self.output_length,
                                                dynamic_size=False, infer_shape=True)
        gen_x_f2 = tensor_array_ops.TensorArray(dtype=tf.int32, size=self.output_length,
                                                dynamic_size=False, infer_shape=True)

        self.neghbor = tf.placeholder(tf.int32, shape=[self.batch_size, self.num_emb])
        # init_neghbor = tf.Variable(tf.zeros([self.batch_size, self.num_emb],dtype=tf.int32))

        _, x_f2, h_f2, g_predictions_2, new_neghbor = control_flow_ops.while_loop(
            cond=lambda i, _1, _2, _3, _4: i < self.input_length,
            body=_pretrain_recurrence_2,
            loop_vars=(tf.constant(0, dtype=tf.int32),
                       tf.nn.embedding_lookup(self.g_embeddings, self.start_token),
                       self.h0, g_predictions_2, self.neghbor))
        _, _, _, _, gen_seq, self.g_predictions_2, new_neghbor = control_flow_ops.while_loop(
            cond=lambda i, _1, _2, _3, _4, _5, _6: i < self.output_length,
            body=_g_recurrence_2,
            loop_vars=(tf.constant(0, dtype=tf.int32),
                       x_f2, h_f2, gen_o_f2, gen_x_f2, g_predictions_2, new_neghbor))

        self.g_predictions_2 = tf.transpose(self.g_predictions_2.stack(), perm=[1, 0, 2])  # batch_size x seq_length x vocab_size
        self.g_pred_prob = self.g_predictions_2[:, self.input_length:, :]
        self.gen_seq = tf.transpose(gen_seq.stack(), perm=[1, 0])  # batch_size x seq_length / 2
        self.gen_x = tf.concat([self.x[:, :self.input_length], self.gen_seq], axis=1)

        def compute_accuracy(x, y):
            intersection = tf.sets.set_intersection(x, y)
            union = tf.sets.set_union(x, y)
            correct_number = tf.cast(tf.sets.set_size(intersection), tf.float32)
            total_number = tf.cast(tf.sets.set_size(union), tf.float32)
            return tf.reduce_mean(correct_number * 1.0 / total_number)

        self.ground_truth = self.x[:, self.input_length:]
        self.accuracy = compute_accuracy(self.gen_seq, self.ground_truth)

        self.train_loss = -tf.reduce_sum(
            tf.one_hot(tf.to_int32(tf.reshape(self.x, [-1])), self.num_emb, 1.0, 0.0) * tf.log(
                tf.clip_by_value(tf.reshape(self.g_predictions_2, [-1, self.num_emb]), 1e-20, 1.0)
            )
        ) / (self.sequence_length * self.batch_size)


    def update(self,):
        self.g_loss = -tf.reduce_sum(
            tf.reduce_sum(
                tf.one_hot(tf.to_int32(tf.reshape(self.ground_truth, [-1])), self.num_emb, 1.0, 0.0) * tf.log(
                    tf.clip_by_value(tf.reshape(self.g_pred_prob, [-1, self.num_emb]), 1e-20, 1.0)
                ), 1) * tf.reshape(self.rewards, [-1])
        )

        g_opt = self.g_optimizer(self.learning_rate)
        self.g_grad, _ = tf.clip_by_global_norm(tf.gradients(self.g_loss, self.g_params), self.grad_clip)
        self.g_updates = g_opt.apply_gradients(zip(self.g_grad, self.g_params))


    def pretrain_step(self, sess, x):
        outputs = sess.run([self.pretrain_updates, self.pretrain_loss], feed_dict={self.x: x})
        return outputs


    def generate_step(self, sess, x):
        feed_dict = {self.x: x, self.neghbor: np.zeros(shape=(self.batch_size, self.num_emb), dtype=np.int32)}
        generate_sequence, generate_prob_table = sess.run([self.gen_x, self.g_predictions_2], feed_dict=feed_dict)
        return generate_sequence, generate_prob_table


    def get_accuracy(self, sess, x):
        feed_dict = {self.x: x, self.neghbor: np.zeros(shape=(self.batch_size, self.num_emb), dtype=np.int32)}
        accuracy, loss = sess.run([self.accuracy, self.train_loss], feed_dict=feed_dict)
        return accuracy, loss


    def update_step(self, sess, x, reward):
        feed_dict = {self.x: x, self.rewards:reward, self.neghbor: np.zeros(shape=(self.batch_size, self.num_emb), dtype=np.int32)}
        _ = sess.run(self.g_updates, feed_dict)



    def init_matrix(self, shape):
        return tf.random_normal(shape, stddev=0.1)

    def init_vector(self, shape):
        return tf.zeros(shape)

    def create_recurrent_unit(self, params):
        # Weights and Bias for input and hidden tensor
        self.Wi = tf.Variable(self.init_matrix([self.emb_dim, self.hidden_dim]))
        self.Ui = tf.Variable(self.init_matrix([self.hidden_dim, self.hidden_dim]))
        self.bi = tf.Variable(self.init_matrix([self.hidden_dim]))

        self.Wf = tf.Variable(self.init_matrix([self.emb_dim, self.hidden_dim]))
        self.Uf = tf.Variable(self.init_matrix([self.hidden_dim, self.hidden_dim]))
        self.bf = tf.Variable(self.init_matrix([self.hidden_dim]))

        self.Wog = tf.Variable(self.init_matrix([self.emb_dim, self.hidden_dim]))
        self.Uog = tf.Variable(self.init_matrix([self.hidden_dim, self.hidden_dim]))
        self.bog = tf.Variable(self.init_matrix([self.hidden_dim]))

        self.Wc = tf.Variable(self.init_matrix([self.emb_dim, self.hidden_dim]))
        self.Uc = tf.Variable(self.init_matrix([self.hidden_dim, self.hidden_dim]))
        self.bc = tf.Variable(self.init_matrix([self.hidden_dim]))
        params.extend([
            self.Wi, self.Ui, self.bi,
            self.Wf, self.Uf, self.bf,
            self.Wog, self.Uog, self.bog,
            self.Wc, self.Uc, self.bc])

        def unit(x, hidden_memory_tm1):
            previous_hidden_state, c_prev = tf.unstack(hidden_memory_tm1)

            # Input Gate
            i = tf.sigmoid(
                tf.matmul(x, self.Wi) +
                tf.matmul(previous_hidden_state, self.Ui) + self.bi
            )

            # Forget Gate
            f = tf.sigmoid(
                tf.matmul(x, self.Wf) +
                tf.matmul(previous_hidden_state, self.Uf) + self.bf
            )

            # Output Gate
            o = tf.sigmoid(
                tf.matmul(x, self.Wog) +
                tf.matmul(previous_hidden_state, self.Uog) + self.bog
            )

            # New Memory Cell
            c_ = tf.nn.tanh(
                tf.matmul(x, self.Wc) +
                tf.matmul(previous_hidden_state, self.Uc) + self.bc
            )

            # Final Memory cell
            c = f * c_prev + i * c_

            # Current Hidden state
            current_hidden_state = o * tf.nn.tanh(c)

            return tf.stack([current_hidden_state, c])

        return unit

    def create_output_unit(self, params):
        self.Wo = tf.Variable(self.init_matrix([self.hidden_dim, self.num_emb]))
        self.bo = tf.Variable(self.init_matrix([self.num_emb]))
        params.extend([self.Wo, self.bo])

        def unit(hidden_memory_tuple):
            hidden_state, c_prev = tf.unstack(hidden_memory_tuple)
            # hidden_state : batch x hidden_dim
            logits = tf.matmul(hidden_state, self.Wo) + self.bo
            # output = tf.nn.softmax(logits)
            return logits

        return unit

    def g_optimizer(self, *args, **kwargs):
        return tf.train.AdamOptimizer(*args, **kwargs)



class ROLLOUT(object):
    def __init__(self, lstm, update_rate):
        self.lstm = lstm
        self.update_rate = update_rate

        self.num_emb = self.lstm.num_emb
        self.batch_size = self.lstm.batch_size
        self.emb_dim = self.lstm.emb_dim
        self.hidden_dim = self.lstm.hidden_dim
        self.sequence_length = self.lstm.sequence_length
        self.input_length = self.lstm.input_length
        self.output_length =self.lstm.output_length
        self.start_token = tf.identity(self.lstm.start_token)
        self.learning_rate = self.lstm.learning_rate

        self.g_embeddings = tf.identity(self.lstm.g_embeddings)
        self.g_recurrent_unit = self.create_recurrent_unit()  # maps h_tm1 to h_t for generator
        self.g_output_unit = self.create_output_unit()  # maps h_t to o_t (output token logits)

        #####################################################################################################
        # placeholder definition
        self.x = tf.placeholder(tf.int32, shape=[self.batch_size, self.sequence_length]) # sequence of tokens generated by generator
        self.given_num = tf.placeholder(tf.int32)

        # processed for batch
        with tf.device("/cpu:0"):
            self.processed_x = tf.transpose(tf.nn.embedding_lookup(self.g_embeddings, self.x), perm=[1, 0, 2])  # seq_length x batch_size x emb_dim

        ta_emb_x = tensor_array_ops.TensorArray(
            dtype=tf.float32, size=self.sequence_length)
        ta_emb_x = ta_emb_x.unstack(self.processed_x)

        ta_x = tensor_array_ops.TensorArray(dtype=tf.int32, size=self.sequence_length)
        ta_x = ta_x.unstack(tf.transpose(self.x, perm=[1, 0]))
        #####################################################################################################

        self.h0 = tf.zeros([self.batch_size, self.hidden_dim])
        self.h0 = tf.stack([self.h0, self.h0])

        gen_x = tensor_array_ops.TensorArray(dtype=tf.int32, size=self.sequence_length,
                                             dynamic_size=False, infer_shape=True)

        self.neghbor = tf.placeholder(tf.int32, shape=[self.batch_size, self.num_emb])
        self.adj = self.lstm.adj

        # When current index i < given_num, use the provided tokens as the input at each time step
        def _g_recurrence_1(i, x_t, h_tm1, given_num, gen_x, neighbor):
            h_t = self.g_recurrent_unit(x_t, h_tm1)  # hidden_memory_tuple
            x_tp1 = ta_emb_x.read(i)
            next_token = ta_x.read(i)
            gen_x = gen_x.write(i, next_token)
            temp = tf.nn.embedding_lookup(self.adj, next_token)
            neighbor = 1 - tf.cast(tf.equal(tf.zeros_like(temp), temp + neighbor), tf.int32)
            return i + 1, x_tp1, h_t, given_num, gen_x, neighbor

        # When current index i >= given_num, start roll-out, use the output as time step t as the input at time step t+1
        def _g_recurrence_2(i, x_t, h_tm1, given_num, gen_x, neighbor):
            h_t = self.g_recurrent_unit(x_t, h_tm1)  # hidden_memory_tuple
            o_t = self.g_output_unit(h_t)
            prob = tf.nn.softmax(o_t)  *  tf.cast(neighbor, tf.float32)
            prob = tf.nn.l2_normalize(prob, dim=1)
            log_prob = tf.log(prob)
            next_token = tf.cast(tf.reshape(tf.multinomial(log_prob, 1), [self.batch_size]), tf.int32)
            x_tp1 = tf.nn.embedding_lookup(self.g_embeddings, next_token)  # batch x emb_dim
            gen_x = gen_x.write(i, next_token)  # indices, batch_size
            temp = tf.nn.embedding_lookup(self.adj, next_token)
            neighbor = 1 - tf.cast(tf.equal(tf.zeros_like(temp), temp + neighbor), tf.int32)

            return i + 1, x_tp1, h_t, given_num, gen_x, neighbor

        i, x_t, h_tm1, given_num, gen_x, new_neighbor = control_flow_ops.while_loop(
            cond=lambda i, _1, _2, given_num, _4, _5: i < given_num,
            body=_g_recurrence_1,
            loop_vars=(tf.constant(0, dtype=tf.int32),
                       tf.nn.embedding_lookup(self.g_embeddings, self.start_token), self.h0, self.given_num, gen_x, self.neghbor))

        _, _, _, _, self.gen_x, new_neighbor = control_flow_ops.while_loop(
            cond=lambda i, _1, _2, _3, _4, _5: i < self.sequence_length,
            body=_g_recurrence_2,
            loop_vars=(i, x_t, h_tm1, given_num, gen_x, new_neighbor))

        self.gen_x = self.gen_x.stack()  # seq_length x batch_size
        self.gen_x = tf.transpose(self.gen_x, perm=[1, 0])  # batch_size x seq_length

    def get_reward(self, sess, input_x, rollout_num, discriminator):
        rewards = []
        for i in range(rollout_num):
            for given_num in range(self.input_length + 1, self.sequence_length):
                feed = {self.x: input_x, self.given_num: given_num, self.neghbor: np.zeros(shape=(self.batch_size, self.num_emb), dtype=np.int32)}
                # feed = {self.x: input_x, self.given_num: given_num}
                samples = sess.run(self.gen_x, feed)
                feed = {discriminator.input_x: samples, discriminator.dropout_keep_prob: 1.0}
                ypred_for_auc = sess.run(discriminator.ypred_for_auc, feed)
                ypred = np.array([item[1] for item in ypred_for_auc])
                if i == 0:
                    rewards.append(ypred)
                else:
                    rewards[given_num - (self.input_length + 1)] += ypred

            # the last token reward
            feed = {discriminator.input_x: input_x, discriminator.dropout_keep_prob: 1.0}
            ypred_for_auc = sess.run(discriminator.ypred_for_auc, feed)
            ypred = np.array([item[1] for item in ypred_for_auc])
            if i == 0:
                rewards.append(ypred)
            else:
                rewards[self.output_length - 1] += ypred

        rewards = np.transpose(np.array(rewards)) / (1.0 * rollout_num)  # batch_size x seq_length
        return rewards

    def create_recurrent_unit(self):
        # Weights and Bias for input and hidden tensor
        self.Wi = tf.identity(self.lstm.Wi)
        self.Ui = tf.identity(self.lstm.Ui)
        self.bi = tf.identity(self.lstm.bi)

        self.Wf = tf.identity(self.lstm.Wf)
        self.Uf = tf.identity(self.lstm.Uf)
        self.bf = tf.identity(self.lstm.bf)

        self.Wog = tf.identity(self.lstm.Wog)
        self.Uog = tf.identity(self.lstm.Uog)
        self.bog = tf.identity(self.lstm.bog)

        self.Wc = tf.identity(self.lstm.Wc)
        self.Uc = tf.identity(self.lstm.Uc)
        self.bc = tf.identity(self.lstm.bc)

        def unit(x, hidden_memory_tm1):
            previous_hidden_state, c_prev = tf.unstack(hidden_memory_tm1)

            # Input Gate
            i = tf.sigmoid(
                tf.matmul(x, self.Wi) +
                tf.matmul(previous_hidden_state, self.Ui) + self.bi
            )

            # Forget Gate
            f = tf.sigmoid(
                tf.matmul(x, self.Wf) +
                tf.matmul(previous_hidden_state, self.Uf) + self.bf
            )

            # Output Gate
            o = tf.sigmoid(
                tf.matmul(x, self.Wog) +
                tf.matmul(previous_hidden_state, self.Uog) + self.bog
            )

            # New Memory Cell
            c_ = tf.nn.tanh(
                tf.matmul(x, self.Wc) +
                tf.matmul(previous_hidden_state, self.Uc) + self.bc
            )

            # Final Memory cell
            c = f * c_prev + i * c_

            # Current Hidden state
            current_hidden_state = o * tf.nn.tanh(c)

            return tf.stack([current_hidden_state, c])

        return unit

    def update_recurrent_unit(self):
        # Weights and Bias for input and hidden tensor
        self.Wi = self.update_rate * self.Wi + (1 - self.update_rate) * tf.identity(self.lstm.Wi)
        self.Ui = self.update_rate * self.Ui + (1 - self.update_rate) * tf.identity(self.lstm.Ui)
        self.bi = self.update_rate * self.bi + (1 - self.update_rate) * tf.identity(self.lstm.bi)

        self.Wf = self.update_rate * self.Wf + (1 - self.update_rate) * tf.identity(self.lstm.Wf)
        self.Uf = self.update_rate * self.Uf + (1 - self.update_rate) * tf.identity(self.lstm.Uf)
        self.bf = self.update_rate * self.bf + (1 - self.update_rate) * tf.identity(self.lstm.bf)

        self.Wog = self.update_rate * self.Wog + (1 - self.update_rate) * tf.identity(self.lstm.Wog)
        self.Uog = self.update_rate * self.Uog + (1 - self.update_rate) * tf.identity(self.lstm.Uog)
        self.bog = self.update_rate * self.bog + (1 - self.update_rate) * tf.identity(self.lstm.bog)

        self.Wc = self.update_rate * self.Wc + (1 - self.update_rate) * tf.identity(self.lstm.Wc)
        self.Uc = self.update_rate * self.Uc + (1 - self.update_rate) * tf.identity(self.lstm.Uc)
        self.bc = self.update_rate * self.bc + (1 - self.update_rate) * tf.identity(self.lstm.bc)

        def unit(x, hidden_memory_tm1):
            previous_hidden_state, c_prev = tf.unstack(hidden_memory_tm1)

            # Input Gate
            i = tf.sigmoid(
                tf.matmul(x, self.Wi) +
                tf.matmul(previous_hidden_state, self.Ui) + self.bi
            )

            # Forget Gate
            f = tf.sigmoid(
                tf.matmul(x, self.Wf) +
                tf.matmul(previous_hidden_state, self.Uf) + self.bf
            )

            # Output Gate
            o = tf.sigmoid(
                tf.matmul(x, self.Wog) +
                tf.matmul(previous_hidden_state, self.Uog) + self.bog
            )

            # New Memory Cell
            c_ = tf.nn.tanh(
                tf.matmul(x, self.Wc) +
                tf.matmul(previous_hidden_state, self.Uc) + self.bc
            )

            # Final Memory cell
            c = f * c_prev + i * c_

            # Current Hidden state
            current_hidden_state = o * tf.nn.tanh(c)

            return tf.stack([current_hidden_state, c])

        return unit

    def create_output_unit(self):
        self.Wo = tf.identity(self.lstm.Wo)
        self.bo = tf.identity(self.lstm.bo)

        def unit(hidden_memory_tuple):
            hidden_state, c_prev = tf.unstack(hidden_memory_tuple)
            # hidden_state : batch x hidden_dim
            logits = tf.matmul(hidden_state, self.Wo) + self.bo
            # output = tf.nn.softmax(logits)
            return logits

        return unit

    def update_output_unit(self):
        self.Wo = self.update_rate * self.Wo + (1 - self.update_rate) * tf.identity(self.lstm.Wo)
        self.bo = self.update_rate * self.bo + (1 - self.update_rate) * tf.identity(self.lstm.bo)

        def unit(hidden_memory_tuple):
            hidden_state, c_prev = tf.unstack(hidden_memory_tuple)
            # hidden_state : batch x hidden_dim
            logits = tf.matmul(hidden_state, self.Wo) + self.bo
            # output = tf.nn.softmax(logits)
            return logits

        return unit

    def update_params(self):
        self.g_embeddings = tf.identity(self.lstm.g_embeddings)
        self.g_recurrent_unit = self.update_recurrent_unit()
        self.g_output_unit = self.update_output_unit()



def linear(input_, output_size, scope=None):
    '''
    Linear map: output[k] = sum_i(Matrix[k, i] * input_[i] ) + Bias[k]
    Args:
    input_: a tensor or a list of 2D, batch x n, Tensors.
    output_size: int, second dimension of W[i].
    scope: VariableScope for the created subgraph; defaults to "Linear".
  Returns:
    A 2D Tensor with shape [batch x output_size] equal to
    sum_i(input_[i] * W[i]), where W[i]s are newly created matrices.
  Raises:
    ValueError: if some of the arguments has unspecified or wrong shape.
  '''

    shape = input_.get_shape().as_list()
    if len(shape) != 2:
        raise ValueError("Linear is expecting 2D arguments: %s" % str(shape))
    if not shape[1]:
        raise ValueError("Linear expects shape[1] of arguments: %s" % str(shape))
    input_size = shape[1]

    # Now the computation.
    with tf.variable_scope(scope or "SimpleLinear"):
        matrix = tf.get_variable("Matrix", [output_size, input_size], dtype=input_.dtype)
        bias_term = tf.get_variable("Bias", [output_size], dtype=input_.dtype)

    return tf.matmul(input_, tf.transpose(matrix)) + bias_term


def highway(input_, size, num_layers=1, bias=-2.0, f=tf.nn.relu, scope='Highway'):
    """Highway Network (cf. http://arxiv.org/abs/1505.00387).
    t = sigmoid(Wy + b)
    z = t * g(Wy + b) + (1 - t) * y
    where g is nonlinearity, t is transform gate, and (1 - t) is carry gate.
    """

    with tf.variable_scope(scope):
        for idx in range(num_layers):
            g = f(linear(input_, size, scope='highway_lin_%d' % idx))

            t = tf.sigmoid(linear(input_, size, scope='highway_gate_%d' % idx) + bias)

            output = t * g + (1. - t) * input_
            input_ = output

    return output


class Discriminator(object):
    """
    A CNN for text classification.
    Uses an embedding layer, followed by a convolutional, max-pooling and softmax layer.
    """

    def __init__(
            self, sequence_length, num_classes, vocab_size,
            embedding_size, filter_sizes, num_filters, l2_reg_lambda=0.0):
        # Placeholders for input, output and dropout
        self.input_x = tf.placeholder(tf.int32, [None, sequence_length], name="input_x")
        self.input_y = tf.placeholder(tf.float32, [None, num_classes], name="input_y")
        self.dropout_keep_prob = tf.placeholder(tf.float32, name="dropout_keep_prob")

        # Keeping track of l2 regularization loss (optional)
        l2_loss = tf.constant(0.0)

        with tf.variable_scope('discriminator'):
            # Embedding layer
            with tf.device('/cpu:0'), tf.name_scope("embedding"):
                self.W = tf.Variable(
                    tf.random_uniform([vocab_size, embedding_size], -1.0, 1.0),
                    name="W")
                self.embedded_chars = tf.nn.embedding_lookup(self.W, self.input_x)
                self.embedded_chars_expanded = tf.expand_dims(self.embedded_chars, -1)

            # Create a convolution + maxpool layer for each filter size
            pooled_outputs = []
            for filter_size, num_filter in zip(filter_sizes, num_filters):
                with tf.name_scope("conv-maxpool-%s" % filter_size):
                    # Convolution Layer
                    filter_shape = [filter_size, embedding_size, 1, num_filter]
                    W = tf.Variable(tf.truncated_normal(filter_shape, stddev=0.1), name="W")
                    b = tf.Variable(tf.constant(0.1, shape=[num_filter]), name="b")
                    conv = tf.nn.conv2d(
                        self.embedded_chars_expanded,
                        W,
                        strides=[1, 1, 1, 1],
                        padding="VALID",
                        name="conv")
                    # Apply nonlinearity
                    h = tf.nn.relu(tf.nn.bias_add(conv, b), name="relu")
                    # Maxpooling over the outputs
                    pooled = tf.nn.max_pool(
                        h,
                        ksize=[1, sequence_length - filter_size + 1, 1, 1],
                        strides=[1, 1, 1, 1],
                        padding='VALID',
                        name="pool")
                    pooled_outputs.append(pooled)

            # Combine all the pooled features
            num_filters_total = sum(num_filters)
            self.h_pool = tf.concat(pooled_outputs, 3)
            self.h_pool_flat = tf.reshape(self.h_pool, [-1, num_filters_total])

            # Add highway
            with tf.name_scope("highway"):
                self.h_highway = highway(self.h_pool_flat, self.h_pool_flat.get_shape()[1], 1, 0)

            # Add dropout
            with tf.name_scope("dropout"):
                self.h_drop = tf.nn.dropout(self.h_highway, self.dropout_keep_prob)

            # Final (unnormalized) scores and predictions
            with tf.name_scope("output"):
                W = tf.Variable(tf.truncated_normal([num_filters_total, num_classes], stddev=0.1), name="W")
                b = tf.Variable(tf.constant(0.1, shape=[num_classes]), name="b")
                l2_loss += tf.nn.l2_loss(W)
                l2_loss += tf.nn.l2_loss(b)
                self.scores = tf.nn.xw_plus_b(self.h_drop, W, b, name="scores")
                self.ypred_for_auc = tf.nn.softmax(self.scores)
                self.predictions = tf.argmax(self.scores, 1, name="predictions")

            # CalculateMean cross-entropy loss
            with tf.name_scope("loss"):
                losses = tf.nn.softmax_cross_entropy_with_logits(logits=self.scores, labels=self.input_y)
                self.loss = tf.reduce_mean(losses) + l2_reg_lambda * l2_loss

        self.params = [param for param in tf.trainable_variables() if 'discriminator' in param.name]
        d_optimizer = tf.train.AdamOptimizer(1e-4)
        grads_and_vars = d_optimizer.compute_gradients(self.loss, self.params, aggregation_method=2)
        self.train_op = d_optimizer.apply_gradients(grads_and_vars)




class Dis_dataloader():
    def __init__(self, batch_size, seq_length):
        self.batch_size = batch_size
        self.seq_length = seq_length
        self.sentences = np.array([])
        self.labels = np.array([])

    def load_train_data(self, positive_examples, negative_examples):
        self.sentences = np.array(positive_examples + negative_examples)

        # Generate labels
        positive_labels = [[0, 1] for _ in positive_examples]
        negative_labels = [[1, 0] for _ in negative_examples]
        self.labels = np.concatenate([positive_labels, negative_labels], 0)

        # Shuffle the data
        shuffle_indices = np.random.permutation(np.arange(len(self.labels)))
        self.sentences = self.sentences[shuffle_indices]
        self.labels = self.labels[shuffle_indices]

        # Split batches
        self.num_batch = int(len(self.labels) / self.batch_size)
        self.sentences = self.sentences[:self.num_batch * self.batch_size]
        self.labels = self.labels[:self.num_batch * self.batch_size]
        self.sentences_batches = np.split(self.sentences, self.num_batch, 0)
        self.labels_batches = np.split(self.labels, self.num_batch, 0)

        self.pointer = 0


    def next_batch(self):
        ret = self.sentences_batches[self.pointer], self.labels_batches[self.pointer]
        self.pointer = (self.pointer + 1) % self.num_batch
        return ret

    def reset_pointer(self):
        self.pointer = 0



def generate_samples(sess, trainable_model, batch_size, train_batch, real_samples):
    # Generate Samples
    generated_samples = []
    for i in range(train_batch):
        samples, _ = trainable_model.generate_step(sess, real_samples[i * batch_size: (i + 1) * batch_size])
        generated_samples.extend(samples)
    return generated_samples


def pre_train_epoch(sess, trainable_model, batch_size, num_batch):
    # Pre-train the generator using MLE for one epoch
    supervised_g_losses = []
    for it in xrange(num_batch):
        batch = utils.train_next_batch(batch_size, hard=True)
        _, g_loss = trainable_model.pretrain_step(sess, batch)
        supervised_g_losses.append(g_loss)
    return np.mean(supervised_g_losses)


def candidate_measure(positive_samples, negative_samples, g_prediction, adjacency_matrix, input_length, num=5, prob=False):
    batch_size, sequence_length, node_num = g_prediction.shape
    correct = 0
    if prob is True:
        for i in range(batch_size):
            generate_sequences = negative_samples[i, input_length:]
            real_sequences = positive_samples[i, input_length:]
            new_prob_table = g_prediction[i, input_length:]
            indices = np.reshape(np.argsort(-new_prob_table, axis=1)[:, :num], [-1]) % node_num
            correct += len((set(indices)|set(real_sequences)) & set(generate_sequences))
    else:
        for i in range(batch_size):
            generate_sequences = negative_samples[i, input_length:]
            real_sequences = positive_samples[i, input_length:]
            train_sequences = positive_samples[i, :input_length]
            neighbors = np.sum(adjacency_matrix[train_sequences], axis=0)
            indices = np.argsort(-neighbors)[:(sequence_length - input_length) * num]
            correct += len((set(indices)|set(real_sequences)) & set(generate_sequences))
    return correct * 1.0 / batch_size / (sequence_length - input_length)


def test_accuracy_epoch(sess, trainable_model, batch_size, num_batch, input_length, adjacency_matrix, num_expend=5):
    accuracy_list = [0.0] * num_batch
    loss_list = [0.0] * num_batch
    p_num_list = [0.0] * num_batch
    n_num_list = [0.0] * num_batch
    for i in xrange(num_batch):
        batch = utils.test_next_batch(batch_size, hard=True)
        neg_batch, g_prediction = trainable_model.generate_step(sess, batch)
        # utils.check_instance(neg_batch, adjacency_matrix, batch_size)
        accuracy_list[i], loss_list[i] = trainable_model.get_accuracy(sess, batch)

        p_num_list[i] = candidate_measure(batch, neg_batch, g_prediction, adjacency_matrix, input_length, num=num_expend,prob=False)
        n_num_list[i] = candidate_measure(batch, neg_batch, g_prediction, adjacency_matrix, input_length, num=num_expend,prob=True)

    return np.mean(accuracy_list), np.mean(loss_list), np.mean(p_num_list), np.mean(n_num_list)


def train_discrimintor(sess, generator, discriminator, epoch_num, batch_size, train_batch, positive_samples, dis_data_loader, dis_dropout_keep_prob = 0.75):
    for _ in range(epoch_num):
        negative_samples = generate_samples(sess, generator, batch_size, train_batch, positive_samples)
        dis_data_loader.load_train_data(positive_samples, negative_samples)
        for _ in range(3):
            dis_data_loader.reset_pointer()
            for it in xrange(dis_data_loader.num_batch):
                x_batch, y_batch = dis_data_loader.next_batch()
                feed = {discriminator.input_x: x_batch, discriminator.input_y: y_batch, discriminator.dropout_keep_prob: dis_dropout_keep_prob}
                _ = sess.run(discriminator.train_op, feed)



def main():
    args = utils.parse_args_new()
    #  Data Parameters
    origin_data_file = args.data_file
    graph_file = args.graph_file
    generated_num = args.num_train_sample
    generated_num_test = args.num_test_sample
    seq_length = args.seq_length
    vocab_size = args.num_node
    batch_size = args.batch_size
    num_epochs = args.num_epochs

    log_file = args.output_file


    #  Generator  Hyper-parameters
    g_emb_dim = args.g_dim_emb
    g_hidden_size = args.g_hidden_size
    g_num_epochs = args.g_epochs
    g_pretrain_epochs = args.g_pretrain_epochs
    train_percent = args.train_percent
    g_num_search = args.g_num_search
    g_update_rate = args.g_update_rate
    g_num_expend = args.g_num_expend

    #  Discriminator  Hyper-parameters
    d_num_epochs = args.d_epochs
    d_pretrain_epochs = args.d_pretrain_epochs
    d_emb_dim = args.d_dim_emb
    d_dropout_prob = args.d_dropout_prob
    d_reg_lambda = args.d_reg_lambda


    dis_filter_sizes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    dis_num_filters = [100, 200, 200, 200, 200, 100, 100, 100, 100, 100]


    START_TOKEN = 0
    SEED = 88
    random.seed(SEED)
    np.random.seed(SEED)
    assert START_TOKEN == 0


    input_length = int(seq_length * train_percent)
    train_batch = int(generated_num / batch_size)
    test_batch = int(generated_num_test / batch_size)

    # Model


    generator = Generator(vocab_size, batch_size, g_emb_dim, g_hidden_size, seq_length, START_TOKEN, input_length, graph_file=graph_file)
    discriminator = Discriminator(sequence_length=seq_length, num_classes=2, vocab_size=vocab_size, embedding_size=d_emb_dim,
                                filter_sizes=dis_filter_sizes, num_filters=dis_num_filters, l2_reg_lambda=d_reg_lambda)

    config = tf.ConfigProto()
    config.gpu_options.allow_growth = True
    sess = tf.Session(config=config)
    sess.run(tf.global_variables_initializer())

    utils.prepare_data(origin_data_file)
    dis_data_loader = Dis_dataloader(batch_size, seq_length)
    positive_samples = utils.feed_data_all(origin_data_file, generated_num)

    graph = nx.read_edgelist(graph_file, nodetype=int, create_using=nx.DiGraph())
    adjacency_matrix = np.asarray(nx.adjacency_matrix(graph).todense()).transpose()

    # log_file = 'save/' + 'n@' + str(g_num_expend) + '_p@' + str(int(train_percent * 10))+ '.txt'
    log = open(log_file, 'w')
    #  pre-train generator
    print 'Start pre-training...'
    log.write('Start pre-training...')
    for epoch in xrange(g_pretrain_epochs):
        loss = pre_train_epoch(sess, generator, batch_size, train_batch)
        print 'pre-train epoch:%d loss:%.3f' % (epoch, loss)
        log.write('pre-train epoch:%d loss:%.3f\n' % (epoch, loss))
        if epoch % 5 == 0:
            accuracy, test_loss, p_n, n_n = test_accuracy_epoch(sess, generator, batch_size, test_batch, input_length, adjacency_matrix, g_num_expend)
            print 'pre-train epoch:%d loss:%.5f jaccard:%.5f p@n:%.5f, n@n:%.5f' % (epoch, test_loss, accuracy, p_n, n_n)
            log.write('pre-train epoch:%d loss:%.5f jaccard:%.5f p@n:%.5f, n@n:%.5f\n' % (epoch, test_loss, accuracy, p_n, n_n))

    print 'Start pre-training discriminator...'
    log.write('Start pre-training discriminator...\n')
    # Train 3 epoch on the generated data and do this for 50 times
    train_discrimintor(sess, generator, discriminator, d_pretrain_epochs, batch_size, train_batch, positive_samples,
                           dis_data_loader, d_dropout_prob)

    rollout = ROLLOUT(generator, g_update_rate)

    print '#########################################################################'
    print 'Start Adversarial Training...'
    log.write('Start Adversarial Training...\n')
    for epoch in range(num_epochs):
        # Train the generator for one step
        for it in range(g_num_epochs):
            no = np.random.randint(0, train_batch)
            samples, _ = generator.generate_step(sess, positive_samples[no * batch_size :(no +1) * batch_size])
            rewards = rollout.get_reward(sess, samples, g_num_search, discriminator)
            generator.update_step(sess, samples, rewards)
        # Test
        if epoch % 5 == 0 or epoch == num_epochs - 1:
            accuracy, test_loss, p_n, n_n = test_accuracy_epoch(sess, generator, batch_size, test_batch, input_length, adjacency_matrix, g_num_expend)
            print 'train epoch:%d loss:%.5f jaccard:%.5f p@n:%.5f, n@n:%.5f' % (epoch, test_loss, accuracy, p_n, n_n)
            log.write('train epoch:%d loss:%.5f jaccard:%.5f p@n:%.5f, n@n:%.5f\n' % (epoch, test_loss, accuracy, p_n, n_n))

        # Update roll-out parameters
        rollout.update_params()

        # Train the discriminator
        train_discrimintor(sess, generator, discriminator, d_num_epochs, batch_size, train_batch, positive_samples,
                           dis_data_loader, d_dropout_prob)


if __name__ == '__main__':
    main()
